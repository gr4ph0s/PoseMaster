# ==============================================
#                   Import
# ==============================================
# localimport-v1.5_b64_lw=99
if bool(1):
    exec("""import base64 as b, zlib as z; s={}; blob=b"\
    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";exec(z.decompress(b.b64decode(blob)), s);localimport=s["localimport"]; del blob, b, z, s;""")

with localimport('.') as _importer:
    import collections
    import c4d

    from ..Helper.Const import Const
# ==============================================
#                   Import
# ==============================================

#Helper tuple for storing GeUserAre coord
Coord = collections.namedtuple('Coord', 'x y')

class UiPoseLibraryView(c4d.gui.GeUserArea):
    """
    This class implements the visual representation of PoseList
    """

    def __init__(self, ui_pose_list, tile_size=Const.UI_MINIATURE_SIZE, tile_space=8, ):
        super(UiPoseLibraryView, self).__init__()
        self.pose_list = ui_pose_list
        self.set_tile_size(tile_size)
        self.tile_space = tile_space

        # only used for speed performance in draw_pose
        self.total_tile_width = 0
        self.max_x_row = 0

    def set_tile_size(self, tile_size):
        self.tile_width = tile_size
        self.tile_height = tile_size * 1.25

    def get_color_vector(self, color_id):
        """
        get_color_vector(color_id) -> c4d.Vector

        Returns a color :class:`c4d.Vector` for *color_id*. The
        existing :meth:`GetColorRGB` method returns a dictionary
        with RGB values in range [0,255] which is rather inconvenient.
        """

        data = self.GetColorRGB(color_id)
        rgbv = c4d.Vector(data['r'], data['g'], data['b'])
        return rgbv ^ c4d.Vector(1.0 / 255.0)

    def calc_pose_pos(self, index):
        """
        Helper function to compute the pixel offset of a miniature.

        :param index: integer representing the order of the miniature
        :return: Coord obj egual to the left top corner of a miniature
        """
        if not self.max_x_row:
            return Coord(0, 0)

        x_row = index % self.max_x_row
        y_row = index // self.max_x_row

        x = (self.tile_space // 2) + ((x_row * self.tile_width) + (x_row * self.tile_space))
        y = (self.tile_space // 2) + ((y_row * self.tile_height) + (y_row * self.tile_space))

        return Coord(x, y)

    def draw_pose(self, pose_id, pose_name, pose_bmp, pose_selected):
        """
        Helper function to draw a pose.

        :param pose_id: integer
            the pose_id in the grid ! 
            Not equivalent to UiPose.id wich is the db one 

        :param pose_name: string
            The actual pose name

        :param pose_bmp: c4d.bitmaps.BaseBitmap
            The bitmap to be used.

        :param pose_selected: Bool
            The state of the selection of the pose

        """

        # Calculate the tile's position on the User Area for both
        # components and convert it to a Coord object immediately.
        pos = self.calc_pose_pos(pose_id)
        size = Coord(self.tile_width, self.tile_height)

        # Draw the top rectangle // Will be BaseBitmpap after
        color = self.get_color_vector(c4d.COLOR_BGFOCUS)
        self.DrawSetPen(color)
        self.DrawRectangle(pos.x, pos.y, pos.x + size.x, pos.y + size.y * 0.75)

        # write pose id
        flags = c4d.DRAWTEXT_HALIGN_CENTER | c4d.DRAWTEXT_VALIGN_CENTER
        self.DrawSetTextCol(c4d.COLOR_TEXT, c4d.COLOR_TRANS)
        self.DrawText(
            str(pose_id), pos.x + size.x / 2, pos.y + (size.y * 0.75) / 2, flags)

        # Draw the bottom rectangle
        color = self.get_color_vector(c4d.COLOR_BGEDIT)
        self.DrawSetPen(color)
        self.DrawRectangle(pos.x, pos.y + size.y * 0.75, pos.x + size.x, pos.y + size.y)

        # Draw the name of the pose
        if pose_selected:
            self.DrawSetTextCol(c4d.COLOR_TEXTFOCUS, c4d.COLOR_TRANS)
        else:
            self.DrawSetTextCol(c4d.COLOR_TEXT, c4d.COLOR_TRANS)

        # reduce the string for matching our block
        while pose_name:
            if self.DrawGetTextWidth(pose_name) > self.tile_width:
                pose_name = pose_name[:-1]
            else:
                break

        self.DrawText(
            str(pose_name), pos.x + size.x / 2, pos.y + size.y * 0.875, flags)

        # Draw outline if selected
        if pose_selected:
            self.DrawBorder(c4d.BORDER_ACTIVE_4, pos.x, pos.y, pos.x + size.x, pos.y + size.y)

    def DrawMsg(self, x1, y1, x2, y2, msg):
        """
        This method is called to render the content of the view.
        """

        # Enables double buffering to avoid flickering.
        self.OffScreenOn()

        # Draw the background.
        self.DrawSetPen(c4d.COLOR_BG)
        self.DrawRectangle(x1, y1, x2, y2)

        # Set the text font, we only need to do this once.
        self.DrawSetFont(c4d.FONT_BOLD)

        # set data for drawing
        self.total_tile_width = self.tile_width + self.tile_space
        self.max_x_row = self.GetWidth() // self.total_tile_width

        # Draw all the poses.
        for tile in self.pose_list.iter_poses():
            self.draw_pose(tile.id, tile.name, tile.bmp, tile.selected)

    def calc_pose_id_by_coord(self, coord):
        """
        Retrieve the actual UiPose id from a coord in UiPoseList.all_poses

        :param coord: the coord in the GeUserArea
        :return: int. Calc_pos_id can retrieve a pose_id which is not into the list ALWAYS CHECK!
        """
        x_row = coord.x // self.total_tile_width
        y_row = coord.y // self.tile_height

        return int(x_row + y_row * self.max_x_row)

    def get_ctrl_shift_alt(self, msg):
        """
        Get if ctrl / shift or alt is pressed
        """
        bc_keyboard = c4d.BaseContainer()
        ctrl = False
        shift = False
        alt = False

        self.GetInputState(c4d.BFM_INPUT_KEYBOARD, c4d.BFM_INPUT_CHANNEL, bc_keyboard)

        if bc_keyboard[c4d.BFM_INPUT_QUALIFIER] & c4d.QCTRL:
            ctrl = True

        if bc_keyboard[c4d.BFM_INPUT_QUALIFIER] & c4d.QSHIFT:
            shift = True

        if bc_keyboard[c4d.BFM_INPUT_QUALIFIER] & c4d.QALT:
            alt = True

        return ctrl, shift, alt

    def get_coord_clicked(self, msg):
        """
        Get where user click in our GeUserArea
        """
        bc_click = c4d.BaseContainer()
        self.GetInputState(c4d.BFM_INPUT_MOUSE, c4d.BFM_INPUT_MOUSELEFT, bc_click)

        # Get position clicked
        base = self.Local2Global()
        coord = Coord(bc_click.GetLong(c4d.BFM_INPUT_X) - base['x'],
                      bc_click.GetLong(c4d.BFM_INPUT_Y) - base['y'])

        return coord

    def Message(self, msg, result):
        if msg.GetId() == c4d.BFM_INPUT:
            # Get state of ctrl / shift / alt
            ctrl, shift, alt = self.get_ctrl_shift_alt(msg)

            # Get position clicked and convert it into pose_id
            pose_id_click = self.calc_pose_id_by_coord(self.get_coord_clicked(msg))

            # Click into a pose
            if self.pose_list.get_number_of_poses() - 1 >= pose_id_click:
                # if only shift is pressed
                if shift and not ctrl and not alt:
                    self.pose_list.toggle_select_pose(pose_id_click)

                # if only ctrl is pressed
                elif ctrl and not shift and not alt:
                    self.pose_list.deselect_pose(pose_id_click)

                # click normal
                else:
                    self.pose_list.deselect_all()
                    self.pose_list.select_pose(pose_id_click)

                # redraw change
                self.Redraw()

            # Click elsewhere on the GeUserArea
            else:
                self.pose_list.deselect_all()
                self.pose_list.select_pose(pose_id_click)
                self.Redraw()

        return super(UiPoseLibraryView, self).Message(msg, result)